# MySQL技术内幕

## 第一章
  * **数据库** 是物理操作系统文件，比如 frm, MYD, MYI, ibd 结尾的文件。
  * **数据库实例** 是一个进程，由后台线程及一个共享内存组成。
  * 数据库实例用来操作数据库文件。
  * 集群环境下，可能一个数据库被多个数据库实例使用。
  * MySQL数据库按 /etc/my.cnf --> /etc/mysql/my.cnf --> /usr/local/mysql/etc/my.cnf --> ~/.my.cnf 顺序读取配置文件。
  * 几个配置文件包含相同的参数，以读取到的最后一个配置文件的参数为准。
  * **数据库是文件的集合，数据库实例是程序**。
  * **存储引擎是基于表的**，而不是数据库。
  * InnoDB特点是**行锁设计**，支持**外键**，**默认读取操作不会产生锁**。MySQL默认存储引擎。
  * InnoDB表单独存放在一个独立的ibd文件中。
  * InnoDB通过使用**多版本并发控制（MVCC）**来获得高并发性。默认为**可重复读**。通过**临键锁来避免幻读**。 
  * 如果没有显式指定主键，会每一行生成一个6字节的ROWID，以此作为主键。
  * MyISAM **不支持事务**，**表锁**设计，支持**全文索引**。**面向OLAP应用**。
  * MyISAM 的缓冲池只**缓存索引文件，而不缓存数据文件**。
  * MyISAM 由MYD和MYI文件组成，MYD存储数据文件，MYI存储索引文件。
  * Memory 引擎默认采用Hash索引，而不是B+树索引。
  * Memory 只支持表锁，并发性较差，**不支持TEXT和BLOB类型**。VARCHAR类型按照CHAR存储。
  * 中间结果集产生的**临时表采用Memory引擎**，但如果包含TEXT和BLOB类型，会转换为MyISAM而损失性能。
  * Archive 引擎**只支持INSERT和SELECT**操作。会对数据进行压缩，压缩比1:10，**非常适合存储归档数据**。
  * ETL操作，MyISAM性能好，OLTP环境，InnoDB性能更好。
  * 不同存储引擎特性比较
  ![不同引擎特性比较][dbengine]
  
  
## 第二章
  * InnoDB缓存池包含：索引页，数据页，undo页，插入缓冲，自适应哈希索引，锁信息，数据字典信息。  
  * InnoDB内存数据对象
  ![InnoDB内存数据对象][dbobject]
  * **SHOW ENGINE INNODB STATUS** 查看InnoDB引擎状态
  * **Buffer pool hit rate** 表示缓冲池的命中率，通常该值不应该小于95%
  * 重做日志缓冲，默认8M，每秒会将重做日志缓冲刷新到日志文件
  * 每个事务提交时会将重做日志缓冲刷新到重做日志文件
  * 事务数据库采用Write Ahead Log策略，即事务提交时，先写重做日志，再修改页
  * 当数据库宕机时，只需对Checkpoint后的重做日志进行恢复
  * 当缓冲池不够时，会强制执行Checkpoint，将脏页刷会磁盘
  * LSN(Log Sequence Number) 标记版本，重做日志有LSN，Checkpoint 也有LSN
  * 当缓冲池中脏页超过75%时，会强制执行Checkpoint，将脏页刷会磁盘
  * innodb_io_capacity 用来表示IO 吞吐量，默认200，当使用SSD时，需要调大这个值
  * 一般聚集索引是顺序的，不需要随机读取，但UUID这类主键，是随机的。
  * 如果是随机插入或者更新，会将插入操作放入Insert Buffer，多个Insert 之后合并操作
  * 自适应Hash索引，通过缓冲池的B+树构建，而不是对整个数据构建，当连续相同的查询条件时，会自动为某些热点也创建哈希索引
  * 当开始事务时，UPDATE操作会创建UNDO日志(undo log)
 
## 第三章
  * 参数文件
  * 日志文件：错误日志、binlog、慢查询日志、查询日志、重做日志等
  * socket文件：当用Unix域套接字方式进行连接时需要的文件
  * pid文件：MySQL实例进程ID文件
  * MySQL表结构文件：存放MySQL表结构定义文件
  * 存储引擎文件 
  * SHOW VARIABLES 查看数据库中所有参数
  * Global 全局参数，Session 当前会话参数
  * autocommit只能在当前会话中修改
  * set global|session 设置动态变量
  * MySQL常见的日志有
    * 错误日志(error log)
    * 二进制日志(binlog)
    * 慢查询日志(slow query log)
    * 查询日志(log)
  * SHOW VARIABLES LIKE 'log_error' 定位错误日志 
  * 慢查询日志默认10秒，long_query_time来设置
  * 默认情况下不启动慢查询日志，需要手工设置 log_slow_queries 为 ON
  * mysqldumpslow -s al -n 10 david.log 导出执行时间最长的10条SQL语句
  * 查询日志默认为 机器名.log
  * 二进制日志(binary log)不包含SELECT 和 SHOW类操作
  * 若修改操作未发生任何变化，该操作也会被记录到binlog
  * 可以通过对binlog进行 point-in-name 进行恢复
  * binlog还可以用来复制从库
  * 通过配置log-bin参数来启动二进制文件
  * 所有未提交的二进制日志会记录到缓存，当事务提交时，直接将缓存中的二进制日志记录到二进制日志文件
  * frm文件存放表和视图结构的定义
  * 重做日志文件(redo log file)
  * **二进制仅在事务提交前提交，不论事务多大，只写磁盘一次**
  * 在事务进行的过程中，不断的有重做日志条目被写入重做日志文件
  * innodb_flush_log_at_trx_commit **设为1，每当有事务提交时，必须确保事务都已写入重做日志文件**
  * 二进制文件支持**STATEMENT（逻辑SQL）、ROW(表的行更改，建议采用该模式)、MIX**三种格式
  
## 第四章
  * 如果没有定义主键，则查找是否有非NULL唯一索引，有则为主键，否则创建6字节大小指针作为主键
  * 所有数据存放在表空间中，表空间又由段，区，页组成
  * InnoDB 逻辑存储结构
  ![InnoDB 逻辑存储结构][innodb_structure]
  * 如果启用innodb_file_per_table，每张表内的数据可以单独存放在一个表空间内，但是只包含数据、索引和插入缓冲
  * B+树的叶子节点为数据段，非叶子节点为索引段
  * 区由连续的页组成，默认的页大小为16K，可以通过innodb_page_size设置
  * 不论页怎么设置，区大小均为1M
  * 每页最多存放16K/2 - 200行数据，即7992行记录
  * NULL除了占有NULL标志位，实际存储不占任何空间
  * 每行数据有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节，如果未定义主键列，还会增加6字节rowid列
  * VARCHAR类型最大为65532字节
  * VARCHAR(N) 中的N为字符的长度，而不是字节的长度
  * InnoDB默认的页为16K，16384字节，当发生行溢出，存放在Uncompress BLOB页
  * 行溢出数据的存储
  ![行溢出出具存储结构]
  * 每个页至少存放两条数据，如果一个页只能存放一条数据，则自动将行数据放到溢出页
  * 如果一个页可以放两条以上的数据，VARCHAR类型数据不会放到BLOB页
  * VARCHAR阈值长度8908，不会放入到BLOB页
  * BLOB/TEXT如果在一个页如果能存放2条数据，不会放到BLOB Page
  * CHAR(N)的N指的是字符长度，不是字节长度
  * 在不同的字符集下，CHAR可能不是定长数据
  * 对于多字符集编码，CHAR不是定长数据，而是变长数据，和VARCHAR没有实际区别
  * InnoDB数据页结构
  ![InnoDB数据页结构]
  * 每个数据页有两个虚拟的行记录Infimun和Supremum，在任何情况下都不会被删除。
  * Page Directory(页目录)存放了记录的相对位置，而不是偏移量
  * B+树索引本身并不能找不到具体的一条记录，而是该记录所在的页
  * 数据库把页载入内存，然后通过Page Directory再进行二叉查找
  * 创建唯一索引，就是创建了一个唯一约束
  * 约束是一个逻辑概念，用来保证数据的完整性，索引是一个数据结构，既有逻辑上的概念，还代表着物理上的存储方式
  * MyISAM存储引擎本身不支持外键，只是起到一个注释的作用，InnoDB完整支持外键约束
  * 被引用的表为父表，引用的表为子表
  * MySQL的外键约束是即时检查
  * SHOW TABLES 会显示出视图
  * Oracle 支持物化视图，根据基表实际存在的实表
  * MySQL 本身不支持物化视图，但可以通过触发器来实现物化视图
  * MySQL 是局部分区索引，一个分区中既存放了数据又存放了索引
  * 全局分区是数据存放在分区，索引存放在统一的地方，MySQL不支持全局分区
  * 唯一索引是可以允许NULL值的
  * MySQL优化器不会搜索所有的分区，Partition Pruning 分区修剪
  * 对于启用分区，应该根据分区特性来编写最优的SQL语句
  * 对于RANGE分区，优化器只能针对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化
  * 对于OLAP应用，分区能很好的提高查询的性能
  
# 第五章
  * 每页Page Directory中的槽是按照主键的顺序存放
  * 索引顺序访问方法：ISAM
  * 机械硬盘每秒至少做100次IO,2-4次IO意味着查询时间只需0.02-0.04秒
  * 不管是聚集索引还是辅助索引，内部都是B+树的
  * 聚集索引和辅助索引不同的是叶子节点是否是一整行的信息
  * 聚集索引的叶子节点称为数据页
  * 每个数据页通过一个双向链表进行连接
  * 一般情况下，查询优化器倾向于采用聚集索引，因为叶子节点能直接访问到数据
  * 数据页存放的是完整的每行的记录
  * 非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量
  * B+树索引
  ![B+树索引]
  * 聚集索引的存储并不是物理上连续的，而是逻辑上连续的，通过双向链表进行维护
  * 页按照主键顺序排序，对于主键的排序查找和范围查找非常快
  * 辅助索引叶子节点并不包含行记录的完整数据
  * 辅助索引叶子节点除了包含键值以外，索引行还包含一个书签
  * InnoDB会遍历辅助索引，通过页级别的指针，获得指向主键索引的主键，然后通过主键索引来找到一个完整记录
  * 辅助索引分析
  ![辅助索引分析]
  * SHOW INDEX FORM 可以查看索引
  * Cardinality 非常关键的值，表示索引中唯一值的数目估计值
  * Cardinality值/表行数 应该接近1，如果非常小，可以考虑删除该索引
  * 创建索引的过程中会对表加S锁，因此创建过程中是只读的
  * 在访问表中很少一部分时使用B+树才有意义，低选择性的字段不建议加索引
  * 联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2
  * 联合索引对第二个键值进行了排序处理，对于联合索引的的排序不需要执行filesort排序
  * 覆盖索引：从辅助索引中就可以查到记录，而不需要查询聚集索引的数据
  * 辅助索引不包含整行记录的信息，其大小远小于聚集索引，可以减少大量的IO
  * 选择辅助索引可以减少IO, 优化器并不会选择聚集索引进行查询统计，而是选择辅助索引
  * 当访问数据占表的较大一部分时(17%)，优化器会选择通过聚集索引来查找数据，也就是全表扫描
  * 顺序读要远远快于离散读
  * 通过辅助索引查找的数据是少量的
  * 若使用固态硬盘，随机读很快，可以通过FORCE INDEX强制使用某个索引
  * 索引提示（Index Hint)显示的告诉优化器使用哪个索引
  * Use Index 并不能强制优化器使用索引，因为需要使用Force Index
  * HASH索引只能搜索等值查询，不能被范围查找使用
  * 自适应HASH索引默认开启
  * 全文检索通过倒排索引实现
  * 倒排索引需要将Word存放在辅助表Auxiliary Table
  * 全文检索索引缓存是一个红黑树
  * 每张表只能有一个全文检索的索引
  * 中文是不支持全文索引的

# 第六章
  * MyISAM是表锁设计，读没有什么问题，并发插入时性能就要差一些
  * latch，轻量级锁，要求锁时间非常短，没有死锁检测机制，分为mutex互斥量和rwlock读写锁
  * lock 的对象是事务，锁定数据库中的对象，如表、页、行
  * lock 仅在事务的commit和rollback后释放，并且有死锁机制
  * lock和latch的比较
  ![lock和latch的比较]
  * InnoDB提供了两种标准的**行级锁**
    * 共享锁(S Lock)，允许事务读一行数据
    * 排他锁(X Lock)，允许事务删除或更新一行数据
  * 如果一个事务T1已经获取了行r的共享锁，另外的事务T2可以立即获取行r的共享锁，这种情况叫做锁兼容
  * 若有其实事务T3想获得行r的排他锁，需要等待T1和T2释放行r上的共享锁，这叫做锁不兼容
  * 共享锁和排他锁的兼容性
  ![共享锁和排他锁的兼容性]
  * S锁和X锁都是行锁
  * X锁和任何锁都不兼容，S锁仅和S锁兼容
  * 意向锁将锁定的对象分为多个层次
  * 如果需要对行r上X锁，需要对数据库、表、页上意向锁IX，最后对记录r上X锁
  * 意向锁为表级别锁
    * 意向共享锁(IS Lock)：事务想要获得一张表中某几行的共享锁
    * 意向排他锁(IX Lock): 事务想要获得一张表中某几行的排他锁
  * 意向锁不会阻塞全表扫以外的任何请求
  * InnoDB锁的兼容性
  ![InnoDB锁的兼容性]
  * 通过INNODB_LOCK_WAITS表，可以直观反应当前事务的等待
  * 一致性非锁定读指InnoDB通过多版本控制读取当前时间数据库中行的数据
  * 一致性非锁定读不会等待锁的释放，而是读取行的一个数据快照
  * 不需要等待行上X锁的释放，快照数据指该行之前版本的数据，通过UNDO段来完成
  * UNDO用来在事务中回滚数据
  * 读取快照数据不需要上锁，因为没有事务需要对历史数据进行修改
  * 一个行记录可能有不止一个快照数据，因此叫做多版本并发控制(MVCC)
  * 在已提交读下，总是读取被锁定行的最新一份快照数据
  * 在可重复读下，总是读取事务开始时的行数据版本
  * 默认配置下的事务隔离级别为可重复读，SELECT使用一致性非锁定读
  * 两种一致性锁定读：
    * SELECT ... FOR UPDATE (加X锁，阻塞其它锁)
    * SELECT ... LOCK IN SHARE MODE (加S锁，阻塞X锁)  
  * innodb_autoinc_lock_mode控制自增模式，默认为1，批量插入不固定条目的时候是表锁，插入固定条目的时候是互斥量累加
  * InnoDB的自增长和MyISAM的自增长实现逻辑不一样，主库InnoDB，从库MyISAM的时候需要考虑这种情况
  * InnoDB下自增长列必须是索引的第一个列，MyISAM没有这个问题
  * InnoDB有三种行锁算法：
    * Record Lock: 单个行记录上的锁
    * Gap Lock: 间隙锁，锁定一个范围，但不包含记录本身
    * Next-Key Lock: Gap Lock + Record Lock 锁定一个范围，同事包括记录本身
  * Record Lock 总是会锁住索引记录，如果没有设置索引，会使用隐式主键来锁定
  * 如果一个索引有 10， 11， 13， 20 四个记录，则Next-Key Lock的区间为：
    ```
    (-∞, 10], (10, 11], (11, 13], (13, 20], (20, +∞)
    ```
  * 当查询的索引含有唯一索引时，InnoDB会对Next-Key Lock进行优化，降级为Record Lock，仅锁住记录本身
  * 幻读指同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能返回之前不存在的行
  * 可重复读采用Next-Key Lock加锁，已提交读仅采用Record Lock加锁
  * 一致性锁定读下，通过索引查询一个值，即使查询的值不存在，锁定的也是一个范围，多个事务并发插入，只会有一个成功，其他的事务抛出死锁
  * 脏数据是指事务对缓冲池中行记录的修改，但还没有提交的数据
  * 脏页是数据库实例内存和磁盘的异步造成的，脏页的刷新是异步的，最终脏页都会刷新到磁盘
  * 脏读是指可以读到脏数据而不是脏页，事务可以读取到别的事务未提交的数据，违反了隔离性
  * 脏读的发生条件需要隔离级别设置为未提交读
  * 不可重复读读到的是已提交的数据，违反了事务一致性要求
  * MySQL官方将不可重复读问题定义为幻读
  * 可重复读隔离级别采用Next-Key Lock，避免了幻读
  * SELECT与UPDATE之前可能还有其他的操作，如果不上锁，可能会产生更新丢失
  * 解决死锁最简单的方式是不能有等待，将任何的等待转化为回滚，事务重新开始
  * innodb_lock_wait_timeout设置超时时间
  * 数据库采用wait-for graph(等待图)来检测死锁，是主动的死锁检测方式
  * 等待图根据数据库的锁信息链表和事务等待链表构造一个图，如果存在回路，则代表存在死锁
  * 若存在死锁，回滚undo量最小的事务
  * wait-for graph采用深度优先方式检查死锁
  * 至少需要2次等待才能产生一次死锁，死锁只存在于并发情况下
  * InnoDB不存在锁升级，根据事务访问的页对锁进行管理

# 第七章
  * ACID: 原子性、一致性、隔离性、持久性
  * 隔离性保证事务提交前对其他事务不可见
  * 持久性保证事务的高可靠性，而不是高可用性
  * 保存点用来通知系统记住事务当前的状态
  * 事务隔离性由锁来保证
  * 事务原子性、一致性、持久性由redo log和undo log来保证
  * redo log 称为重做日志，用来保证事务的原子性和持久性
  * undo log 用来保证事务的一致性
  * redo log 恢复提交事务修改的页的操作
  * undo log 回滚行记录到某个特定的版本
  * redo 是物理日志，记录的是页的物理修改操作
  * undo 是逻辑日志，根据每行记录进行记录
  * 重做日志有两部分，一部分是内存中的重做日志缓冲，一部分是重做日志文件，是持久性的
  * 当事务提交时，必须先将事重做日志务所有日志写入到重做日志文件进行持久化后，事务的commit操作才算完成
  * 重做日志包含 redo log 和 undo log 两部分
  * redo log是顺序读写的，undo log是随机读写的
  * innodb_flush_log_at_trx_commit 用来控制重做日志刷新到磁盘的策略，默认为1，表示事务提交时必须调用一次刷新操作
  * 二进制日志(binlog) 用来进行POINT-TIME(PIT)的恢复及主从复制环境的建立
  * 重做日志由InnoDB引擎产生，binlog由数据库上层产生，任何引擎都可以产生binlog
  * binlog是逻辑日志，记录的是对应的sql语句，重做日志是物理格式日志，记录的是对每个页的修改
  * binlog只在事务提交完成后进行一次写入，重做日志在事务进行中不断的被写入
  * 重做日志并不随事务提交顺序写入
  * 重做日志块的大小和磁盘扇区大小一样，都是512字节，写入可以保证原子性
  * 重做日志还包含日志头和日志尾，日志实际存储为492字节
  * 重做日志格式是基于页的
  * LSN，日志序列号，单调递增，表示的含义有：
    * 重做日志写入的总量
    * checkpoint的位置
    * 页的版本
  * 不管上次数据库运行时是否正常关闭，InnoDB启动时都会尝试进行恢复操作
  * 重做日志记录的是物理日志，是幂等的，恢复的会很快，仅需恢复checkpoint开始的日志部分
  * binlog日志不是幂等的，重复执行可能会插入多条重复的记录
  * redo存放在重做日志文件中，undo存放在数据库特殊的一个段中，成为undo段，位于共享表空间中
  * undo是逻辑日志
  * 出了回滚操作外，undo的另一个操作是MVCC，以此实现非锁定读
  * undo log 也会产生 redo log
  * 事务提交后不会马上删除 undo log 及 undo log 所在的页，需要由purge线程来判断
  * undo log分为两种：insert undo log 和 update undo log
  * insert undo log 因为insert对其他事务不可见，可以在事务提交后直接删除，不需要purge操作
  * update undo log 记录的是update和delete操作产生的undo log，该操作提供MVCC机制，不能在事务提交时删除，提交时放入undo log链表，等待purge线程删除
  * innodb_purge_batch_size用来设置每次purge操作需要清理的undo page数量
  * BLGC(Binary Log Group Commit):
    * Flush 阶段，将每个事务的二进制日志写入到内存中
    * Sync 阶段，将内存中的二进制日志写入到磁盘，如果队列中有多个事务，那么一次fsync操作完成所有事务的二进制日志文件写入
    * leader根据顺序调用事务的提交
  * 多个事务提交时放入队列，第一个事务为leader，其他事务为follower
  * MySQL默认事务时自动提交的，显示的开启一个事务需要SET AUTOCOMMIT = 0 或者 BEGIN、START TRANSACTION
  * TPS = (com_commit + com_rollback)/time，这种计算方式的前提是所有事务必须是显示的提交
  * ORACLE不支持未提交读和可重复读
  * 隔离级别越低，事务请求的锁越少或者保持锁的时间越短
  * 已提交读下，不会使用gap lock，并且binlog的主从复制必须为row
  * 分布式事务使用两段式提交，任何一个节点显示不能提交，所有的节点都被告知回滚，并且比本地事务多一次prepare操作，所有节点同意后才能commit或者rollback
  * 每一次提交都会写一次重做日志，因此批量操作进行放到一个事务里，一次提交
  
# 第八章
  * 日志备份分为：
    * 完全备份
    * 增量备份
    * 日志备份
  * 日志备份主要指对binlog进行备份，通过对一个完全备份进行二进制日志的重做(replay)，来完成数据库的POINT-IN-TIME恢复工作
  * 对于InnoDB的备份，务必加上 --single-transaction 选项，获得一致性备份，因为这个备份是在一个很长的事务中完成
  * 任何备份都要做好远程异地备份
  * 冷备：备份frm文件，共享表空间文件，独立表空间文件(*.ibd)，重做日志文件，my.cnf文件，需要避免磁盘已满的情况
  * 一致性读不能隔离DDL操作，备份时避免DDL语句执行
  * 默认情况下并不启动二进制日志，需要手工启用
    ```
    [mysqld]
    log-bin = mysql-bin
    sync_binlog = 1 
    innodb_support_xa = 1
    ```    
  * 二进制的恢复应该是point-in-time的恢复而不是增量备份
  * Linux 逻辑管理器 LVM(Logic Volume Manager)，使用Copy-on-write技术来创建快照
  * 主从复制分是三个步骤：
    * master 将数据更改记录到binlog中
    * slave把master的binlog复制到自己的中继日志(relay log)中
    * slave重做中级日志中的日志，把更改应用到自己的数据库上
  * 主从复制是异步实时，如果主服务器压力大，会导致从服务器延时较大
  * MySQL主从复制工作原理
  ![MySQL主从复制工作原理]
  * 从服务器有两个线程，一个是I/O线程，负责读取主服务器binlog日志，并保存为中继日志，另一个是SQL线程，复制执行中继日志
  * SHOW MASTER STATUS 可以查看主服务器中binlog的状态
  * 当主服务器发生误操作时，只需要将从服务器上的快照进行恢复，然后再根据binlog进行point-in-time的恢复即可
  * 快照+复制的备份结构
  ![快照+复制的备份结构]
  * 建议从服务器设置只读，避免其他线程修改
  
    
  
    
  
  
  









  
  [dbengine]: img/dbengine.png 
  [dbobject]: img/dbobject.png
  [innodb_structure]: img/innodb_structure.png
  [行溢出出具存储结构]: img/行溢出数据存储结构.png
  [InnoDB数据页结构]: img/InnoDB数据页结构.png
  [B+树索引]: img/B+Tree.png
  [辅助索引分析]: img/辅助索引分析.png
  [lock和latch的比较]: img/lock和latch的比较.png
  [共享锁和排他锁的兼容性]: img/共享锁和排他锁的兼容性.png
  [InnoDB锁的兼容性]: img/InnoDB锁的兼容性.png
  [MySQL主从复制工作原理]: img/MySQL主从复制工作原理.png
  [快照+复制的备份结构]: img/快照+复制的备份结构.png