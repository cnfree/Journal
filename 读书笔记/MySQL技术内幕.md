# MySQL技术内幕

## 第一章
  * **数据库** 是物理操作系统文件，比如 frm, MYD, MYI, ibd 结尾的文件。
  * **数据库实例** 是一个进程，由后台线程及一个共享内存组成。
  * 数据库实例用来操作数据库文件。
  * 集群环境下，可能一个数据库被多个数据库实例使用。
  * MySQL数据库按 /etc/my.cnf --> /etc/mysql/my.cnf --> /usr/local/mysql/etc/my.cnf --> ~/.my.cnf 顺序读取配置文件。
  * 几个配置文件包含相同的参数，以读取到的最后一个配置文件的参数为准。
  * **数据库是文件的集合，数据库实例是程序**。
  * **存储引擎是基于表的**，而不是数据库。
  * InnoDB特点是**行锁设计**，支持**外键**，**默认读取操作不会产生锁**。MySQL默认存储引擎。
  * InnoDB表单独存放在一个独立的ibd文件中。
  * InnoDB通过使用**多版本并发控制（MVCC）**来获得高并发性。默认为**可重复读**。通过**临键锁来避免幻读**。 
  * 如果没有显式指定主键，会每一行生成一个6字节的ROWID，以此作为主键。
  * MyISAM **不支持事务**，**表锁**设计，支持**全文索引**。**面向OLAP应用**。
  * MyISAM 的缓冲池只**缓存索引文件，而不缓存数据文件**。
  * MyISAM 由MYD和MYI文件组成，MYD存储数据文件，MYI存储索引文件。
  * Memory 引擎默认采用Hash索引，而不是B+树索引。
  * Memory 只支持表锁，并发性较差，**不支持TEXT和BLOB类型**。VARCHAR类型按照CHAR存储。
  * 中间结果集产生的**临时表采用Memory引擎**，但如果包含TEXT和BLOB类型，会转换为MyISAM而损失性能。
  * Archive 引擎**只支持INSERT和SELECT**操作。会对数据进行压缩，压缩比1:10，**非常适合存储归档数据**。
  * ETL操作，MyISAM性能好，OLTP环境，InnoDB性能更好。
  * 不同存储引擎特性比较
  ![不同引擎特性比较][dbengine]
  
  
## 第二章
  * InnoDB缓存池包含：索引页，数据页，undo页，插入缓冲，自适应哈希索引，锁信息，数据字典信息。  
  * InnoDB内存数据对象
  ![InnoDB内存数据对象][dbobject]
  * **SHOW ENGINE INNODB STATUS** 查看InnoDB引擎状态
  * **Buffer pool hit rate** 表示缓冲池的命中率，通常该值不应该小于95%
  * 重做日志缓冲，默认8M，每秒会将重做日志缓冲刷新到日志文件
  * 每个事务提交时会将重做日志缓冲刷新到重做日志文件
  * 事务数据库采用Write Ahead Log策略，即事务提交时，先写重做日志，再修改页
  * 当数据库宕机时，只需对Checkpoint后的重做日志进行恢复
  * 当缓冲池不够时，会强制执行Checkpoint，将脏页刷会磁盘
  * LSN(Log Sequence Number) 标记版本，重做日志有LSN，Checkpoint 也有LSN
  * 当缓冲池中脏页超过75%时，会强制执行Checkpoint，将脏页刷会磁盘
  * innodb_io_capacity 用来表示IO 吞吐量，默认200，当使用SSD时，需要调大这个值
  * 一般聚集索引是顺序的，不需要随机读取，但UUID这类主键，是随机的。
  * 如果是随机插入或者更新，会将插入操作放入Insert Buffer，多个Insert 之后合并操作
  * 自适应Hash索引，通过缓冲池的B+树构建，而不是对整个数据构建，当连续相同的查询条件时，会自动为某些热点也创建哈希索引
  * 当开始事务时，UPDATE操作会创建UNDO日志(undo log)
 
## 第三章
  * 参数文件
  * 日志文件：错误日志、binlog、慢查询日志、查询日志、重做日志等
  * socket文件：当用Unix域套接字方式进行连接时需要的文件
  * pid文件：MySQL实例进程ID文件
  * MySQL表结构文件：存放MySQL表结构定义文件
  * 存储引擎文件 
  * SHOW VARIABLES 查看数据库中所有参数
  * Global 全局参数，Session 当前会话参数
  * autocommit只能在当前会话中修改
  * set global|session 设置动态变量
  * MySQL常见的日志有
    * 错误日志(error log)
    * 二进制日志(binlog)
    * 慢查询日志(slow query log)
    * 查询日志(log)
  * SHOW VARIABLES LIKE 'log_error' 定位错误日志 
  * 慢查询日志默认10秒，long_query_time来设置
  * 默认情况下不启动慢查询日志，需要手工设置 log_slow_queries 为 ON
  * mysqldumpslow -s al -n 10 david.log 导出执行时间最长的10条SQL语句
  * 查询日志默认为 机器名.log
  * 二进制日志(binary log)不包含SELECT 和 SHOW类操作
  * 若修改操作未发生任何变化，该操作也会被记录到binlog
  * 可以通过对binlog进行 point-in-name 进行恢复
  * binlog还可以用来复制从库
  * 通过配置log-bin参数来启动二进制文件
  * 所有未提交的二进制日志会记录到缓存，当事务提交时，直接将缓存中的二进制日志记录到二进制日志文件
  * frm文件存放表和视图结构的定义
  * 重做日志文件(redo log file)
  * **二进制仅在事务提交前提交，不论事务多大，只写磁盘一次**
  * 在事务进行的过程中，不断的有重做日志条目被写入重做日志文件
  * innodb_flush_log_at_trx_commit **设为1，每当有事务提交时，必须确保事务都已写入重做日志文件**
  * 二进制文件支持**STATEMENT（逻辑SQL）、ROW(表的行更改，建议采用该模式)、MIX**三种格式
  
## 第四章
  * 如果没有定义主键，则查找是否有非NULL唯一索引，有则为主键，否则创建6字节大小指针作为主键
  * 所有数据存放在表空间中，表空间又由段，区，页组成
  * InnoDB 逻辑存储结构
  ![InnoDB 逻辑存储结构][innodb_structure]
  * 如果启用innodb_file_per_table，每张表内的数据可以单独存放在一个表空间内，但是只包含数据、索引和插入缓冲
  * B+树的叶子节点为数据段，非叶子节点为索引段
  * 区由连续的页组成，默认的页大小为16K，可以通过innodb_page_size设置
  * 不论页怎么设置，区大小均为1M
  * 每页最多存放16K/2 - 200行数据，即7992行记录
  * NULL除了占有NULL标志位，实际存储不占任何空间
  * 每行数据有两个隐藏列，事务ID列和回滚指针列，分别为6字节和7字节，如果未定义主键列，还会增加6字节rowid列
  * VARCHAR类型最大为65532字节
  * VARCHAR(N) 中的N为字符的长度，而不是字节的长度
  * InnoDB默认的页为16K，16384字节，当发生行溢出，存放在Uncompress BLOB页
  * 行溢出数据的存储
  ![行溢出出具存储结构]
  * 每个页至少存放两条数据，如果一个页只能存放一条数据，则自动将行数据放到溢出页
  * 如果一个页可以放两条以上的数据，VARCHAR类型数据不会放到BLOB页
  * VARCHAR阈值长度8908，不会放入到BLOB页
  * BLOB/TEXT如果在一个页如果能存放2条数据，不会放到BLOB Page
  * CHAR(N)的N指的是字符长度，不是字节长度
  * 在不同的字符集下，CHAR可能不是定长数据
  * 对于多字符集编码，CHAR不是定长数据，而是变长数据，和VARCHAR没有实际区别
  * InnoDB数据页结构
  ![InnoDB数据页结构]
  * 每个数据页有两个虚拟的行记录Infimun和Supremum，在任何情况下都不会被删除。
  * Page Directory(页目录)存放了记录的相对位置，而不是偏移量
  * B+树索引本身并不能找不到具体的一条记录，而是该记录所在的页
  * 数据库把页载入内存，然后通过Page Directory再进行二叉查找
  * 创建唯一索引，就是创建了一个唯一约束
  * 约束是一个逻辑概念，用来保证数据的完整性，索引是一个数据结构，既有逻辑上的概念，还代表着物理上的存储方式
  * MyISAM存储引擎本身不支持外键，只是起到一个注释的作用，InnoDB完整支持外键约束
  * 被引用的表为父表，引用的表为子表
  * MySQL的外键约束是即时检查
  * SHOW TABLES 会显示出视图
  * Oracle 支持物化视图，根据基表实际存在的实表
  * MySQL 本身不支持物化视图，但可以通过触发器来实现物化视图
  * MySQL 是局部分区索引，一个分区中既存放了数据又存放了索引
  * 全局分区是数据存放在分区，索引存放在统一的地方，MySQL不支持全局分区
  * 唯一索引是可以允许NULL值的
  * MySQL优化器不会搜索所有的分区，Partition Pruning 分区修剪
  * 对于启用分区，应该根据分区特性来编写最优的SQL语句
  * 对于RANGE分区，优化器只能针对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化
  * 对于OLAP应用，分区能很好的提高查询的性能
  
# 第五章
  * 每页Page Directory中的槽是按照主键的顺序存放
  * 索引顺序访问方法：ISAM
  * 机械硬盘每秒至少做100次IO,2-4次IO意味着查询时间只需0.02-0.04秒
  * 不管是聚集索引还是辅助索引，内部都是B+树的
  * 聚集索引和辅助索引不同的是叶子节点是否是一整行的信息
  * 聚集索引的叶子节点称为数据页
  * 每个数据页通过一个双向链表进行连接
  * 一般情况下，查询优化器倾向于采用聚集索引，因为叶子节点能直接访问到数据
  * 数据页存放的是完整的每行的记录
  * 非数据页的索引页中，存放的仅仅是键值及指向数据页的偏移量
  * B+树索引
  ![B+树索引]
  * 聚集索引的存储并不是物理上连续的，而是逻辑上连续的，通过双向链表进行维护
  * 页按照主键顺序排序，对于主键的排序查找和范围查找非常快
  * 辅助索引叶子节点并不包含行记录的完整数据
  * 辅助索引叶子节点除了包含键值以外，索引行还包含一个书签
  * InnoDB会遍历辅助索引，通过页级别的指针，获得指向主键索引的主键，然后通过主键索引来找到一个完整记录
  * 辅助索引分析
  ![辅助索引分析]
  * SHOW INDEX FORM 可以查看索引
  * Cardinality 非常关键的值，表示索引中唯一值的数目估计值
  * Cardinality值/表行数 应该接近1，如果非常小，可以考虑删除该索引
  * 创建索引的过程中会对表加S锁，因此创建过程中是只读的
  * 在访问表中很少一部分时使用B+树才有意义，低选择性的字段不建议加索引
  * 联合索引也是一棵B+树，不同的是联合索引的键值数量不是1，而是大于等于2
  * 联合索引对第二个键值进行了排序处理，对于联合索引的的排序不需要执行filesort排序
  * 覆盖索引：从辅助索引中就可以查到记录，而不需要查询聚集索引的数据
  * 辅助索引不包含整行记录的信息，其大小远小于聚集索引，可以减少大量的IO
  * 选择辅助索引可以减少IO, 优化器并不会选择聚集索引进行查询统计，而是选择辅助索引
  * 当访问数据占表的较大一部分时(17%)，优化器会选择通过聚集索引来查找数据，也就是全表扫描
  * 顺序读要远远快于离散读
  * 通过辅助索引查找的数据是少量的
  * 若使用固态硬盘，随机读很快，可以通过FORCE INDEX强制使用某个索引
  * 索引提示（Index Hint)显示的告诉优化器使用哪个索引
  * Use Index 并不能强制优化器使用索引，因为需要使用Force Index
  * HASH索引只能搜索等值查询，不能被范围查找使用
  * 自适应HASH索引默认开启
  * 全文检索通过倒排索引实现
  * 倒排索引需要将Word存放在辅助表Auxiliary Table
  * 全文检索索引缓存是一个红黑树
  * 每张表只能有一个全文检索的索引
  * 中文是不支持全文索引的










  
  [dbengine]: img/dbengine.png 
  [dbobject]: img/dbobject.png
  [innodb_structure]: img/innodb_structure.png
  [行溢出出具存储结构]: img/行溢出数据存储结构.png
  [InnoDB数据页结构]: img/InnoDB数据页结构.png
  [B+树索引]: img/B+Tree.png
  [辅助索引分析]: img/辅助索引分析.png