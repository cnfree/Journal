# 对称加密和非对称加密

# 对称加密
 * 对称加密是最**快速**、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）
 
 * 对称加密通常使用的是**相对较小的密钥**，一般小于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。
 
 * 对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是**将对称加密的密钥进行非对称加密，然后传送给需要它的人**。
 
 * 常见的对称加密算法有: DES、3DES、Blowfish、IDEA、RC4、RC5、RC6 和 AES。
 
 * **DES 现在已经不被视为一种安全的加密算法，主要原因是它使用的56位密钥过短。**
 
 * **DES/AES加密速度快，适合大量数据，比如文件加密**，处理数据后可复原。
 
 * AES五种加密模式（CBC、ECB、CTR、OCF、CFB），虽然有五种加密，但是常用的还是CBC，CBC的全称Cipher Block Chaining ，有点类似于区块链
 
 * 常见对称算法对比
 
    ![对称加密算法对比]
 
 [对称加密算法对比]:img/对称加密算法对比.png
 
# 非对称加密算法
  * 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 
  
  * 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。
  
  * 优点：安全
  
  * 缺点：**速度较慢**
  
  * 常见的非对称加密算法有: RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）
  
  * RSA，**对极大整数做因数分解**的难度 (The Factoring Problem) 决定了 RSA 算法的可靠性。换言之，对一个极大整数做因数分解愈困难，RSA 算法就愈可靠。
  
  * 非对称加密要想完全不被破解，就是要求能找到一个完全不能找到反函数的函数。现在非对称加密只是破解要花多少时间的问题，不存在绝对不能破解的算法。
  
  * 所以目前公钥和私钥都是**定期更换**的，这个就能基本保证安全了。
  
 # 非对称加密的常见应用场景
 
 1. 信息加密
 　　
    * 收信者是唯一能够解开加密信息的人，因此收信者手里的必须是私钥。发信者手里的是公钥，其它人知道公钥没有关系，因为其它人发来的信息对收信者没有意义。
 
 2. 登录认证 
    
    * 客户端需要将认证标识传送给服务器，此认证标识（可能是一个随机数）其它客户端可以知道，因此需要用私钥加密，客户端保存的是私钥。服务器端保存的是公钥，其它服务器知道公钥没有关系，因为客户端不需要登录其它服务器。
 
 3. 数字签名 
    * 数字签名是为了表明信息没有受到伪造，确实是信息拥有者发出来的，附在信息原文的后面。就像手写的签名一样，具有不可抵赖性和简洁性。
      * 简洁性：对信息原文做hash，得到digest。信息越短加密的耗时越少。
      * 不可抵赖性：信息拥有者要保证签名的唯一性，必须是唯一能够加密digest的人，因此必须用私钥加密(就像字迹他人无法学会一样)，得到签名。如果用公钥，那每个人都可以伪造签名了。
 
 4. 数字证书
    
    * 问题起源：对1和3，发信者怎么知道从网上获取的公钥就是真的？没有遭受中间人攻击？

    * 这样就需要第三方机构来保证公钥的合法性，这个第三方机构就是CA（Certificate Authority），证书中心。
 
    * CA用自己的私钥对信息原文所有者发布的公钥和相关信息进行加密，得出的内容就是数字证书。
 
    * 信息原文的所有者以后发布信息时，除了带上自己的签名，还带上数字证书，就可以保证信息不被篡改了。信息的接收者先用CA给的公钥解出信息所有者的公钥，这样可以保证信息所有者的公钥是真正的公钥，然后就能通过该公钥证明数字签名是否真实了。
    
 # 散列（Hashing）算法   
 
 * 在信息安全领域，将源数据经过散列算法计算出数据指纹(data fingerprint)，用于识别经过传播途径得到的数据是否有误 (通信误码或被窜改)，以保证数据的来源真实性。
 
 * Message Digest(MD5) 输入不定长度信息，经过程序流程，生成四个32位数据，最后联合起来输出固定128bit长度的信息摘要。
 
 * Secure Hash Algorithm(SHA-1、SHA-256)，SHA-1 生成一个被称为消息摘要的160位（20字节）散列值，SHA-2是组合值，有不同的位数，其中最受欢迎的是256位。
 
 * 从去年起，SHA-2成为了新的标准，所以现在签发的SSL证书，必须使用该算法签名。
 
 * 加密哈希算法的一个重要功能是产生独特的散列，当两个不同的值或文件可以产生相同的散列，则会创建所谓的碰撞。只有在不发生碰撞时，才能保证数字签名的安全性。
 
 * 因为SHA-1的大小结构都碰撞的机率比较大，所以SHA-1被认为是不安全的。对于SHA-256，有2的256次方种组合。这是一个庞大的数值。
 
 # 散列算法应用场景
 
 * MD5/SHA用于完整性，确保信息在传输过程保持一致性；
 
 * 用于密码加密，数据库中不存储密码明文，而是存储其散列值，校验时比较散列值是否相同
 
 # 组合使用
 
 * 采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，使用散列函数进行数据摘要
 
 ## 密钥salt和初始化向量IV(initialization vector)
 
 * 密钥salt在加密算法中主要被设计用来防止“字典攻击”。字典攻击也是一种穷举的暴力破解法。字典中会假设一定数量的密码值，攻击者会尝试用这些密码来解密密文。Salt是在密钥导出之前在密码末尾引入的随机字节，它使这类攻击变得非常困难。
 
 * 初始化向量IV在加密算法中起到的也是增强破解难度的作用。在加密过程中，如果遇到相同的数据块，其加密出来的结果也一致，相对就会容易破解。加密算法在加密数据块的时候，往往会同时使用密码和上一个数据块的加密结果。因为要加密的第一个数据块显然不存在上一个数据块，所以这个初始化向量就是被设计用来当作初始数据块的加密结果。
 
 * 加密时，用IV和Key去加密第一个块，然后用第一个块的加密数据作为下一个块的iv，依次迭代。解密时，用n-1个块的加密数据作为iv和key去解密第n个块（n>1），只有第一个块才会用加密时的iv去解密第一个块。按照这样的逻辑来看，那么如果解密时，使用了iv错误，出问题的数据应该只有第一个块。
   